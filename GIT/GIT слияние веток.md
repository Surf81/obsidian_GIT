
# GIT слияние веток
***
Команды: `merge`, `rebase`, `cherry-pick`
***
[git merge](#git%20merge)
[git rebase](#git%20rebase)
[git cherry-pick](#git%20cherry-pick)

## `git merge`
***


| | |
|-|-|
|git merge <сливаемая ветка>|сливает изменения из указанной ветки в текущую|
|ключи:||
|--ff|включить fast-forward, если возможно (читать ниже) (используется по умолчанию) - если есть возможность, новый коммит не создается, а просто перемещается указатель|
|--no-ff|отключить fast-forward (провести явное слияние) - всегда создается новый commit, включающий информацию о слиянии|
|--ff-only|остановить слияние, если невозможно сделать fast-forward|

>fast-forward возможен только если в ветке-родителе после ответвления нет новых коммитов. В этом случае указатель ветки-родителя просто перемещается на последний коммит сливаемой ветки. Это называется неявное слияние

>По умолнянию GIT пытается делать неявное слияние
>Если провести неявное слияние, коммиты в текущей ветке, внесенные после ответвления, будут утеряны

>При явном слиянии создается новый коммит (merge-коммит), имеющий обратные ссылки на двух родителей

### Разрешение конфликтов слияния

Очень часто во время слияния веток оказывается, что ваши изменения удаляют или переписывают информацию в уже существующих файлах. Такая ситуация называется **файловым конфликтом**. Git останавливает выполнение слияния, пока вы не разрешите конфликт

>По сути, Git сталкивается с проблемой: у него есть два файла с одним и тем же именем, и он не знает, какой из них взять. Поэтому обращается к нам за помощью

В состоянии конфликта указатель ветки выглядит так:
```bash
(master | MERGED)
```

#### Отменить слияние

```bash
git merge --abort
```

#### Разрешение конфликтов

>рекомендуется настроить GIT. Настройка будет дополнительно выводить исходный вариант файла-родителя при сравнении и отображении расхождений двух коммитов

```bash
$ git config --global merge.conflictstyle diff3
```


###### Вариант 1. 
Вручную отредактировать конфликтный текст (не обязательно придерживаться одной из версий. Можно вообще его удалить или переписать по другому)

>В состоянии конфликта все конфликтующие файлы в репозитории изменяются. В них добавляются метки, содержащие обе версии файлов, одну из которых можно удалить, другую оставить. Редактируем файлы прямо в локальном репозитории

>В сообщении merge-коммита следует указывать полезную информацию: какие ветки вы слили, по какому принципу вы сливали файлы, если были конфликты, какие изменения внесли и т.д.

###### Вариант 2.
Выбрать файл, который будет сохранен
```bash
git checkout --ours <file>  # сохраняется версия файла текущей ветки, на которой находится указатель HEAD (целевой ветки)

git checkout --their <file>  # сохраняется версия файла сливаемой ветки
```

Можно воспользоваться графическим интерфесом для разрешения конфликтов:

```bash
git mergetool
```

#### Завершение разрешения конфликтов

```bash
git add <filename> или git add -A, чтобы добавить в индекс сразу все файлы, конфликты которых разрешены. После этого следует сообщить Git, что мы можем продолжить слияние

git merge --continue  ## продолжить слияние
```


## `git rebase`
***


| | |
|-|-|
|git rebase <целевая ветка>|Перемещает все коммиты: от общего коммита двух веток до последнего коммита текущей ветки на вершину переданной ветки<br>Создает указатель ORIG_HEAD на последний коммит сливаемой ветки|
|ключи:||
|-i<br>--interactive|позволяет делать rebase в интерактивном режиме. Применается при редактировании старых коммитов|

Пример
```bash
# Переключимся на ветку для разработки  
$ git checkout develop  
# Перенесем коммиты ветки develop на верхушку ветку main  
$ git rebase main
```


#### Отменить процедуру `rebase`

```bash
git rebase --abort  # в процессе проведения

git reset --hard ORIG_HEAD  # после проведения
```

#### Разрешение конфликтов

>если во время выполнения одного из шагов по применению дельты возникнет конфликт, вы обнаружите, что находитесь в состоянии **detached head**. В это время в вашей рабочей копии будут все изменения дельты, кроме конфликтных. Не стоит пугаться, просто разрешите конфликты, добавьте изменения в индекс и продолжите ребейз командой:  

```bash
$ git rebase --continue
```

Пропустить коммит без разрешения конфликтов:

```bash
git rebase --skip  # пропустить коммит, не добавлять его в результат
```

### Редактирование старых коммитов

[[GIT редактирование старых коммитов]]


## `git cherry-pick`
***

| | |
|-|-|
|git cherry-pick <хеш коммита><br>git cherry-pick <хеш первого коммита> … <хеш последнего коммита>|Берет переданный коммит(ы) и создает в текущей ветке его точную копию|

Пример

```bash
# Находясь на основной ветке  
$ git cherry-pick 48efdd9
```

```bash
# Несколько коммитов, где A более старый. A игнорируется 
$ git cherry-pick A..B
```

```bash
# Несколько коммитов, где A более старый. A включительно
$ git cherry-pick A^..B

# В Windows:
$ git cherry-pick "A^..B"
# или
$ git cherry-pick A^^..B
```

Когда использовать:
**1. Случай первый. Работа в команде.**  
Часто в команде несколько разработчиков работают над одним и тем же участком кода, но каждый – в своей ветке. Соответственно могут возникать ситуации, когда одному из разработчиков для реализации своей части задачи потребуется часть кода, написанная другим разработчиком. **Merge** в данном случае делать нерационально, поскольку ни одна из веток не пришла к своему логическому завершению, а вот **cherry-pick** – то, что надо.  
  
**2. Случай второй. Быстрые исправления багов.**  
Если в коде был обнаружен баг, очень важно как можно быстрее донести исправления до конечного пользователя. В таком случае, разработчик, обнаруживший ошибку, срочно создает коммит, в котором исправляет ее. Этот коммит может быть перенесен в основную ветку с помощью cherry-pick, чтобы не задерживать исправление бага слияниями в различные пре-релизные ветки.  
  
**3. Случай третий. Восстановление утерянных коммитов.**  
Иногда возникают ситуации, когда вы из-за каких-то манипуляций потеряли определенный коммит. Например, сделали **git reset --hard**, начали новую ветку, сделали несколько коммитов и только тут обнаружили пропажу. С помощью **git log** и **git reflog** вы можете узнать хеш утерянного коммита, а затем выполнить **git cherry-pick**, чтобы вернуть его обратно.
