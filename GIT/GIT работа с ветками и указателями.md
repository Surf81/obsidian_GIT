# Ветки GIT
#gitbranch #gitcheckout #gitreset #gitrevert
***
Команды: `branch`, `checkout`, `reset`, `revert`   Почитать: <https://smartiqa.ru/courses/git/lesson-4>
***
[[#Создание ветки]]
[[#Переключение между ветками]]
[[#Смещение указателя]]
[[#Откат последних изменений или объединение коммитов]]
[[#Слияние веток]]
[[#Удаление ветки]]
[[#Откат коммита]]

## Создание ветки

|branch| |
|-|-|
|git branch <ключ> <имя ветки>|создание ветки (текущие рабочие данные при создании ветки не копируются, просто создается новый указатель на текущий коммит)|
|git branch|вывести список локальных веток (символом `*` помечается текущая ветка)|
|git branch -v|вывести список локальных веток с указанием коммита|
|git branch -r|вывести список удаленных (remote) веток|
|git branch -a|вывести список всех существующих веток|

## Создание новой локальной ветки из удаленной

```bash
git checkout -b <имя локальной ветки> <origin/имя удаленной ветки>
```

## Создать ветку, которая будет отслеживать изменения ветки удаленного репозитория

```shell
git branch --track <имя> origin/<имя>

# например если в удаленном репозитории есть ветка origin/style
git branch --track style origin/style
```

## Присоединение локальной ветки к удаленной

```bash
git branch local_branch_name --set-upstream-to origin/remote_branch_name

git branch local_branch_name -u your_new_remote/remote_branch_name

# В старых версиях:
git branch --set-upstream local_branch_name your_new_remote/remote_branch_name
```

## Переключение между ветками

>ВАЖНО! при переключении на другую ветку, все незакомиченные изменения смешаются с загруженным коммитом выбранной ветки!!!! 
>Поэтому состояния перед переключением должно быть чистое!!!

>Перед переключением на другую ветку нужно или закоммитить текущие изменения или заморозить их с помощью [stash](GIT stash)

|checkout | |
|-|-|
|git checkout <ключ> <имя ветки>|переключение на ветку|
|git checkout -b <имя ветки>|создает ветку и сразу переключается на нее|
|git checkout -|переключение на предыдущую ветку|

## Смещение указателя

| | |
|-|-|
|git checkout <путь>|Переводит курсор **HEAD** на указанный коммит или другой указатель|
|git checkout HEAD^|Смещает указатель на предыдущий коммит|
|git checkout HEAD~2|Смещает указатель на 2 коммита назад|

>до смещения указателя
                                          HEAD
                                              |
                                           main
                                              |
comm1------comm2------comm3

>после смещения указателя на 2 коммита назад
HEAD
   |
   |                                       main
   |                                          |
comm1------comm2------comm3

>Такое состояние, когда **HEAD** указывает не на указатель ветки, а непосредственно на сам коммит, называется **detached head**.

>Коммиты, созданные в состоянии detached head не сохраняются в истории. Для возврата из этого состояния нужно создать новую ветку или переключиться на существующую.
>Создать новую ветку можно даже если уже были созданы коммиты в режиме detached head `git checkout -b <имя ветки>` главное сделать это до переключения на другую ветку или коммит

## Откат последних изменений или объединение коммитов

|git reset <ключи> <адрес коммита>|смещает указатель HEAD вместе с указателем ветки #gitreset <br>Создается новый указатель `ORIG_HEAD` на последний коммит|
|-|-|
|ключи:||
|--soft|указатель будет передвинут, но файлы в рабочей копии и индексе останутся без изменения<br>Используется для слияния нескольких коммитов в один|
|--hard|все изменения будут удалены, файлы в рабочей копии и в индексе откатятся к коммиту, к которому делается `reset`|
|--mixed|файлы в рабочей копии останутся без изменений, индекс будет откачен к коммиту, к которому делается `reset`|

##### Отмена произведенного отката

```bash
git reset ORIG_HEAD  # указатель ветки вернется на коммит, с которого делался `reset` даже если использовался ключ `--hard`
```

##### Редактирование последнего коммита

```bash
git reset --soft HEAD^  # откат к предпоследнему коммит с сохранением файлов
git add  #обновление индекса коммит с учетом последних изменений
git commit -C ORIG_HEAD  # обновление коммита с сохранением описания; -c для изменения описания
```
аналогично предыдущему:

```bash
git add  # обновить индекс или очистить текущее состояния
git commit --amend -m "новое имя для последнего коммита"
```

##### Объединение нескольких коммитов

```bash
git reset --soft HEAD~5  # откат на 5 коммитов назад с сохранением файлов
git add  # обновление индекса с учетом последних изменений
git commit -c ORIG_HEAD  # обновление коммита с возможностью редактирования описания
```


## Слияние веток

[Про слияние тут](GIT%20слияние%20веток)

## Удаление ветки

>При удалении ветки все изменения, не внесенные в коммит, будут утеряны

| | |
|-|-|
|git branch -d <имя ветки><br>git branch --delete <имя ветки>|удаление ветки произойдет, только если она полностью слита с другой веткой. иначе выдаст отказ|
|git branch -D <имя ветки>|удалит ветку в любом случае|


## Откат коммита

|git revert <ключи> <адрес коммита>|создает новый коммит, который отменяет изменения внесенные в переданном коммите (последовательности коммитов)<br>Новый коммит появится в истории, а старые останутся|
|-|-|
|git revert HEAD~2|отменить изменения, внесенные 2 коммита назад|
|git revert HEAD~5..HEAD~2|отменить изменения, внесенные в коммитах начиная с 5 с конца до 2 с конца|
|git revert --abort|отменить проведенный откат|

>не должно быть незакоммиченых изменений в рабочей директории, ведь мы все-таки делаем реверт-коммит. Если у вас есть таковые, лучшим решением станет закоммитить (или удалить) все изменения, и только потом делать реверт

